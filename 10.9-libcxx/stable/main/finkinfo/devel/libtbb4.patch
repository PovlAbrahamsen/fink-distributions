diff -ruN tbb43_20150424oss-orig/include/tbb/concurrent_priority_queue.h tbb43_20150424oss/include/tbb/concurrent_priority_queue.h
--- tbb43_20150424oss-orig/include/tbb/concurrent_priority_queue.h	2015-04-24 08:13:33.000000000 -0500
+++ tbb43_20150424oss/include/tbb/concurrent_priority_queue.h	2023-03-24 06:20:07.000000000 -0500
@@ -373,7 +373,7 @@
                     compare(data[0], data[data.size()-1])) {
                     // there are newly pushed elems and the last one
                     // is higher than top
-                    *(tmp->elem) = move(data[data.size()-1]);
+                    *(tmp->elem) = std::move(data[data.size()-1]);
                     __TBB_store_with_release(my_size, my_size-1);
                     itt_store_word_with_release(tmp->status, uintptr_t(SUCCEEDED));
                     data.pop_back();
@@ -389,7 +389,7 @@
                     if (tmp->type == PUSH_OP) {
                         push_back_helper(*(tmp->elem), typename internal::use_element_copy_constructor<value_type>::type());
                     } else {
-                        data.push_back(move(*(tmp->elem)));
+                        data.push_back(std::move(*(tmp->elem)));
                     }
                     __TBB_store_with_release(my_size, my_size + 1);
                     itt_store_word_with_release(tmp->status, uintptr_t(SUCCEEDED));
@@ -413,13 +413,13 @@
                     compare(data[0], data[data.size()-1])) {
                     // there are newly pushed elems and the last one is
                     // higher than top
-                    *(tmp->elem) = move(data[data.size()-1]);
+                    *(tmp->elem) = std::move(data[data.size()-1]);
                     __TBB_store_with_release(my_size, my_size-1);
                     itt_store_word_with_release(tmp->status, uintptr_t(SUCCEEDED));
                     data.pop_back();
                 }
                 else { // extract top and push last element down heap
-                    *(tmp->elem) = move(data[0]);
+                    *(tmp->elem) = std::move(data[0]);
                     __TBB_store_with_release(my_size, my_size-1);
                     itt_store_word_with_release(tmp->status, uintptr_t(SUCCEEDED));
                     reheap();
@@ -439,14 +439,14 @@
         for (; mark<data.size(); ++mark) {
             // for each unheapified element under size
             size_type cur_pos = mark;
-            value_type to_place = move(data[mark]);
+            value_type to_place = std::move(data[mark]);
             do { // push to_place up the heap
                 size_type parent = (cur_pos-1)>>1;
                 if (!compare(data[parent], to_place)) break;
-                data[cur_pos] = move(data[parent]);
+                data[cur_pos] = std::move(data[parent]);
                 cur_pos = parent;
             } while( cur_pos );
-            data[cur_pos] = move(to_place);
+            data[cur_pos] = std::move(to_place);
         }
     }
 
@@ -461,12 +461,12 @@
                 ++target;
             // target now has the higher priority child
             if (compare(data[target], data[data.size()-1])) break;
-            data[cur_pos] = move(data[target]);
+            data[cur_pos] = std::move(data[target]);
             cur_pos = target;
             child = (cur_pos<<1)+1;
         }
         if (cur_pos != data.size()-1)
-            data[cur_pos] = move(data[data.size()-1]);
+            data[cur_pos] = std::move(data[data.size()-1]);
         data.pop_back();
         if (mark > data.size()) mark = data.size();
     }
